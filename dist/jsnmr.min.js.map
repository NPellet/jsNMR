{
  "version": 3,
  "sources": [
    "build_utils/almond.js",
    "shape.1dnmr.js",
    "assignment.js",
    "nmr.js"
  ],
  "names": [],
  "mappings": ";;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,AC5aA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACzPA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,AC7gBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA",
  "file": "jsnmr.min.js",
  "sourcesContent": [
    "/**\n * @license almond 0.3.2 Copyright jQuery Foundation and other contributors.\n * Released under MIT license, http://github.com/requirejs/almond/LICENSE\n */\n//Going sloppy to avoid 'use strict' string cost, but strict practices should\n//be followed.\n/*global setTimeout: false */\n\nvar requirejs, require, define;\n(function (undef) {\n    var main, req, makeMap, handlers,\n        defined = {},\n        waiting = {},\n        config = {},\n        defining = {},\n        hasOwn = Object.prototype.hasOwnProperty,\n        aps = [].slice,\n        jsSuffixRegExp = /\\.js$/;\n\n    function hasProp(obj, prop) {\n        return hasOwn.call(obj, prop);\n    }\n\n    /**\n     * Given a relative module name, like ./something, normalize it to\n     * a real name that can be mapped to a path.\n     * @param {String} name the relative name\n     * @param {String} baseName a real name that the name arg is relative\n     * to.\n     * @returns {String} normalized name\n     */\n    function normalize(name, baseName) {\n        var nameParts, nameSegment, mapValue, foundMap, lastIndex,\n            foundI, foundStarMap, starI, i, j, part, normalizedBaseParts,\n            baseParts = baseName && baseName.split(\"/\"),\n            map = config.map,\n            starMap = (map && map['*']) || {};\n\n        //Adjust any relative paths.\n        if (name) {\n            name = name.split('/');\n            lastIndex = name.length - 1;\n\n            // If wanting node ID compatibility, strip .js from end\n            // of IDs. Have to do this here, and not in nameToUrl\n            // because node allows either .js or non .js to map\n            // to same file.\n            if (config.nodeIdCompat && jsSuffixRegExp.test(name[lastIndex])) {\n                name[lastIndex] = name[lastIndex].replace(jsSuffixRegExp, '');\n            }\n\n            // Starts with a '.' so need the baseName\n            if (name[0].charAt(0) === '.' && baseParts) {\n                //Convert baseName to array, and lop off the last part,\n                //so that . matches that 'directory' and not name of the baseName's\n                //module. For instance, baseName of 'one/two/three', maps to\n                //'one/two/three.js', but we want the directory, 'one/two' for\n                //this normalization.\n                normalizedBaseParts = baseParts.slice(0, baseParts.length - 1);\n                name = normalizedBaseParts.concat(name);\n            }\n\n            //start trimDots\n            for (i = 0; i < name.length; i++) {\n                part = name[i];\n                if (part === '.') {\n                    name.splice(i, 1);\n                    i -= 1;\n                } else if (part === '..') {\n                    // If at the start, or previous value is still ..,\n                    // keep them so that when converted to a path it may\n                    // still work when converted to a path, even though\n                    // as an ID it is less than ideal. In larger point\n                    // releases, may be better to just kick out an error.\n                    if (i === 0 || (i === 1 && name[2] === '..') || name[i - 1] === '..') {\n                        continue;\n                    } else if (i > 0) {\n                        name.splice(i - 1, 2);\n                        i -= 2;\n                    }\n                }\n            }\n            //end trimDots\n\n            name = name.join('/');\n        }\n\n        //Apply map config if available.\n        if ((baseParts || starMap) && map) {\n            nameParts = name.split('/');\n\n            for (i = nameParts.length; i > 0; i -= 1) {\n                nameSegment = nameParts.slice(0, i).join(\"/\");\n\n                if (baseParts) {\n                    //Find the longest baseName segment match in the config.\n                    //So, do joins on the biggest to smallest lengths of baseParts.\n                    for (j = baseParts.length; j > 0; j -= 1) {\n                        mapValue = map[baseParts.slice(0, j).join('/')];\n\n                        //baseName segment has  config, find if it has one for\n                        //this name.\n                        if (mapValue) {\n                            mapValue = mapValue[nameSegment];\n                            if (mapValue) {\n                                //Match, update name to the new value.\n                                foundMap = mapValue;\n                                foundI = i;\n                                break;\n                            }\n                        }\n                    }\n                }\n\n                if (foundMap) {\n                    break;\n                }\n\n                //Check for a star map match, but just hold on to it,\n                //if there is a shorter segment match later in a matching\n                //config, then favor over this star map.\n                if (!foundStarMap && starMap && starMap[nameSegment]) {\n                    foundStarMap = starMap[nameSegment];\n                    starI = i;\n                }\n            }\n\n            if (!foundMap && foundStarMap) {\n                foundMap = foundStarMap;\n                foundI = starI;\n            }\n\n            if (foundMap) {\n                nameParts.splice(0, foundI, foundMap);\n                name = nameParts.join('/');\n            }\n        }\n\n        return name;\n    }\n\n    function makeRequire(relName, forceSync) {\n        return function () {\n            //A version of a require function that passes a moduleName\n            //value for items that may need to\n            //look up paths relative to the moduleName\n            var args = aps.call(arguments, 0);\n\n            //If first arg is not require('string'), and there is only\n            //one arg, it is the array form without a callback. Insert\n            //a null so that the following concat is correct.\n            if (typeof args[0] !== 'string' && args.length === 1) {\n                args.push(null);\n            }\n            return req.apply(undef, args.concat([relName, forceSync]));\n        };\n    }\n\n    function makeNormalize(relName) {\n        return function (name) {\n            return normalize(name, relName);\n        };\n    }\n\n    function makeLoad(depName) {\n        return function (value) {\n            defined[depName] = value;\n        };\n    }\n\n    function callDep(name) {\n        if (hasProp(waiting, name)) {\n            var args = waiting[name];\n            delete waiting[name];\n            defining[name] = true;\n            main.apply(undef, args);\n        }\n\n        if (!hasProp(defined, name) && !hasProp(defining, name)) {\n            throw new Error('No ' + name);\n        }\n        return defined[name];\n    }\n\n    //Turns a plugin!resource to [plugin, resource]\n    //with the plugin being undefined if the name\n    //did not have a plugin prefix.\n    function splitPrefix(name) {\n        var prefix,\n            index = name ? name.indexOf('!') : -1;\n        if (index > -1) {\n            prefix = name.substring(0, index);\n            name = name.substring(index + 1, name.length);\n        }\n        return [prefix, name];\n    }\n\n    /**\n     * Makes a name map, normalizing the name, and using a plugin\n     * for normalization if necessary. Grabs a ref to plugin\n     * too, as an optimization.\n     */\n    makeMap = function (name, relName) {\n        var plugin,\n            parts = splitPrefix(name),\n            prefix = parts[0];\n\n        name = parts[1];\n\n        if (prefix) {\n            prefix = normalize(prefix, relName);\n            plugin = callDep(prefix);\n        }\n\n        //Normalize according\n        if (prefix) {\n            if (plugin && plugin.normalize) {\n                name = plugin.normalize(name, makeNormalize(relName));\n            } else {\n                name = normalize(name, relName);\n            }\n        } else {\n            name = normalize(name, relName);\n            parts = splitPrefix(name);\n            prefix = parts[0];\n            name = parts[1];\n            if (prefix) {\n                plugin = callDep(prefix);\n            }\n        }\n\n        //Using ridiculous property names for space reasons\n        return {\n            f: prefix ? prefix + '!' + name : name, //fullName\n            n: name,\n            pr: prefix,\n            p: plugin\n        };\n    };\n\n    function makeConfig(name) {\n        return function () {\n            return (config && config.config && config.config[name]) || {};\n        };\n    }\n\n    handlers = {\n        require: function (name) {\n            return makeRequire(name);\n        },\n        exports: function (name) {\n            var e = defined[name];\n            if (typeof e !== 'undefined') {\n                return e;\n            } else {\n                return (defined[name] = {});\n            }\n        },\n        module: function (name) {\n            return {\n                id: name,\n                uri: '',\n                exports: defined[name],\n                config: makeConfig(name)\n            };\n        }\n    };\n\n    main = function (name, deps, callback, relName) {\n        var cjsModule, depName, ret, map, i,\n            args = [],\n            callbackType = typeof callback,\n            usingExports;\n\n        //Use name if no relName\n        relName = relName || name;\n\n        //Call the callback to define the module, if necessary.\n        if (callbackType === 'undefined' || callbackType === 'function') {\n            //Pull out the defined dependencies and pass the ordered\n            //values to the callback.\n            //Default to [require, exports, module] if no deps\n            deps = !deps.length && callback.length ? ['require', 'exports', 'module'] : deps;\n            for (i = 0; i < deps.length; i += 1) {\n                map = makeMap(deps[i], relName);\n                depName = map.f;\n\n                //Fast path CommonJS standard dependencies.\n                if (depName === \"require\") {\n                    args[i] = handlers.require(name);\n                } else if (depName === \"exports\") {\n                    //CommonJS module spec 1.1\n                    args[i] = handlers.exports(name);\n                    usingExports = true;\n                } else if (depName === \"module\") {\n                    //CommonJS module spec 1.1\n                    cjsModule = args[i] = handlers.module(name);\n                } else if (hasProp(defined, depName) ||\n                           hasProp(waiting, depName) ||\n                           hasProp(defining, depName)) {\n                    args[i] = callDep(depName);\n                } else if (map.p) {\n                    map.p.load(map.n, makeRequire(relName, true), makeLoad(depName), {});\n                    args[i] = defined[depName];\n                } else {\n                    throw new Error(name + ' missing ' + depName);\n                }\n            }\n\n            ret = callback ? callback.apply(defined[name], args) : undefined;\n\n            if (name) {\n                //If setting exports via \"module\" is in play,\n                //favor that over return value and exports. After that,\n                //favor a non-undefined return value over exports use.\n                if (cjsModule && cjsModule.exports !== undef &&\n                        cjsModule.exports !== defined[name]) {\n                    defined[name] = cjsModule.exports;\n                } else if (ret !== undef || !usingExports) {\n                    //Use the return value from the function.\n                    defined[name] = ret;\n                }\n            }\n        } else if (name) {\n            //May just be an object definition for the module. Only\n            //worry about defining if have a module name.\n            defined[name] = callback;\n        }\n    };\n\n    requirejs = require = req = function (deps, callback, relName, forceSync, alt) {\n        if (typeof deps === \"string\") {\n            if (handlers[deps]) {\n                //callback in this case is really relName\n                return handlers[deps](callback);\n            }\n            //Just return the module wanted. In this scenario, the\n            //deps arg is the module name, and second arg (if passed)\n            //is just the relName.\n            //Normalize module name, if it contains . or ..\n            return callDep(makeMap(deps, callback).f);\n        } else if (!deps.splice) {\n            //deps is a config object, not an array.\n            config = deps;\n            if (config.deps) {\n                req(config.deps, config.callback);\n            }\n            if (!callback) {\n                return;\n            }\n\n            if (callback.splice) {\n                //callback is an array, which means it is a dependency list.\n                //Adjust args if there are dependencies\n                deps = callback;\n                callback = relName;\n                relName = null;\n            } else {\n                deps = undef;\n            }\n        }\n\n        //Support require(['a'])\n        callback = callback || function () {};\n\n        //If relName is a function, it is an errback handler,\n        //so remove it.\n        if (typeof relName === 'function') {\n            relName = forceSync;\n            forceSync = alt;\n        }\n\n        //Simulate async callback;\n        if (forceSync) {\n            main(undef, deps, callback, relName);\n        } else {\n            //Using a non-zero value because of concern for what old browsers\n            //do, and latest browsers \"upgrade\" to 4 if lower value is used:\n            //http://www.whatwg.org/specs/web-apps/current-work/multipage/timers.html#dom-windowtimers-settimeout:\n            //If want a value immediately, use require('id') instead -- something\n            //that works in almond on the global level, but not guaranteed and\n            //unlikely to work in other AMD implementations.\n            setTimeout(function () {\n                main(undef, deps, callback, relName);\n            }, 4);\n        }\n\n        return req;\n    };\n\n    /**\n     * Just drops the config on the floor, but returns req in case\n     * the config return value is used.\n     */\n    req.config = function (cfg) {\n        return req(cfg);\n    };\n\n    /**\n     * Expose module registry for debugging and tooling\n     */\n    requirejs._defined = defined;\n\n    define = function (name, deps, callback) {\n        if (typeof name !== 'string') {\n            throw new Error('See almond README: incorrect module build, no module name');\n        }\n\n        //This module may not have dependencies\n        if (!deps.splice) {\n            //deps is not an array, so probably means\n            //an object literal or factory function for\n            //the value. Adjust args.\n            callback = deps;\n            deps = [];\n        }\n\n        if (!hasProp(defined, name) && !hasProp(waiting, name)) {\n            waiting[name] = [name, deps, callback];\n        }\n    };\n\n    define.amd = {\n        jQuery: true\n    };\n}());\ndefine(\"build_utils/almond\", function(){});\n\n",
    "\ndefine( 'shape.1dnmr',[ 'jquery', 'jsgraph' ], function( $, Graph ) {\n\n\t\"use strict\";\n\tvar lineHeight = 5;\n\tvar GraphLine = Graph.getConstructor( 'graph.shape.line' );\n\n\tfunction GraphNmrSignal1D( graph, options ) {\n\n\t\tthis.options = options || 2;\n\t\t\n\t}\n\n\t$.extend(GraphNmrSignal1D.prototype, GraphLine.prototype, {\n\t\t\n\t\tcreateDom: function() {\n\t\t\t\n\n\t      this._createHandles( 2, 'rect', {\n\t        transform: \"translate(-3 -3)\",\n\t        width: 6,\n\t        height: 6,\n\t        stroke: \"black\",\n\t        fill: \"white\",\n\t        cursor: 'nwse-resize'\n\t      } );\n\n\t\t\tthis._dom = document.createElementNS(this.graph.ns, 'line');\n\t\t\tthis.maxLines = 64;\n\t\t\tthis.nbLines = 0;\n\n\t\t\tthis.maxLines = 0;\n\n\n\t\t\tthis.lines = new Array(this.maxLines);\n\t\t\t\n\n\t\t\t/*this._createHandles( this.nbHandles, 'rect', { \n\t\t\t\ttransform: \"translate(-3 -3)\", \n\t\t\t\twidth: 6, \n\t\t\t\theight: 6, \n\t\t\t\tstroke: \"black\", \n\t\t\t\tfill: \"white\",\n\t\t\t\tcursor: 'nwse-resize'\n\t\t\t} );*/\n\n\n\t\t\t//I dont know how to remove the previous lines, so, I'll create an array of\n\t\t\t//empty lines that can be filled up by the system.\n\t\t\tfor(var i=this.maxLines-1;i>=0;i--){\n\t\t\t\tthis.lines[i] = document.createElementNS( this.graph.ns, 'line');\n\t\t\t\tthis.group.appendChild( this.lines[i]);\n\t\t\t\tthis.lines[i].setAttribute('stroke', 'green');\n\t\t\t}\n\t\t\t\n\t\t\t// calculate a \"hard\"-threshold as in\n\t\t\t// IEEE Transactions on biomedical engineering, vol. 52, no. 1, january\n\t\t\t// 2005, p. 76-\n\t\t\t// keep the number of standard deviations variable\n\t\t\t//nbStandardDeviations=1;\n\t\t\tvar j,mean=0,std=0,max = 0;\n\t\t\tvar serie = this.graph.series[0].data[0];\n\t\t\t//console.log(serie.length);\n\t\t\tfor(j=0;j<serie.length;j+=2){\n\t\t\t\tif(Math.abs(serie[ j + 1 ])>max)\n\t\t\t\t\tmax = Math.abs(serie[ j + 1 ]);\n\t\t\t}\n\t\t\tfor(j=0;j<serie.length;j+=2){\n\t\t\t\tmean+=serie[ j + 1 ]/max;\n\t\t\t}\n\t\t\tfor(j=0;j<serie.length;j+=2)\n\t\t\t\tstd+=Math.pow(mean-serie[ j + 1 ]/max,2);\n\t\t\tstd=Math.sqrt(max)*Math.sqrt(std*2/serie.length);\n\t\t\tthis.noiseLevel = std*3;//3 is the given number of std for nucleus 1H. For 13C it is 1.\n\t\t\t//console.log(\"noiseLevel \"+this.noiseLevel);\n\t\t\t//this.noiseLevel = 4e6;\n\t\t\t\n\t\t\tthis._dom.element = this;\n\t\t},\n\n\n\t\tredrawImpl: function() {\n\n\t\t\tthis.setHandles();\n\t\t\tthis.redrawLines( lineHeight );\n\t\t\t//this.setBindableToDom( this._dom );\n\t\t},\n\n\n\t\tredrawLines: function( height ) {\n\n\t\t\tif( this.maxLines == 0 ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tvar peaks = this.findxs();\n\t\t\t//this.lines = [];\n\t\t\tfor(var i=peaks.length-1;i>=0;i--){\n\t\t\t    //TODO How to know the base of the spectrum?????\n\t\t\t    var baseLine = this._getPosition( { x: 10 } );\n\t\t\t\tvar x1 = this._getPosition( { x: peaks[i][0] } );\n\t\t\t\tif( this.lines[i] && x1.x && this.currentPos2y && this.currentPos1y && i<this.maxLines ) {\n\t\t\t\t\tthis.lines[i].setAttribute('stroke', 'green');\n\t\t\t\t\tthis.lines[i].setAttribute('x1', x1.x );\n\t\t\t\t\tthis.lines[i].setAttribute('x2', x1.x );\n\t\t\t\t\tthis.lines[i].setAttribute('y1', x1.y);\n\t\t\t\t\tthis.lines[i].setAttribute('y2', baseLine.y  );\n\t\t\t\t\tthis.lines[i].setAttribute('on', true );\n\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(var i=peaks.length;i<this.nbLines;i++){\n\n\t\t\t\tif( this.lines[i] ) {\n\t\t\t\t    this.lines[i].setAttribute('y1', parseFloat(this.lines[i].getAttribute('y2')));\n\t\t\t\t    this.lines[i].setAttribute('x1', -1000000 );\n\t\t\t\t\tthis.lines[i].setAttribute('x2', -1000000 );\n\t\t\t\t\tthis.lines[i].setAttribute('on', false );\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tthis.nbLines = peaks.length;\n\n\t\t},\n\n\t\thighLigthLinesY: function( height ) {\n\t\t\tfor(var i=this.lines.length-1;i>=0;i--){\n\t\t\t\tif(this.lines[i].getAttribute('on')==\"true\")\n\t\t\t\t\tthis.lines[i].setAttribute('y1', parseFloat(this.lines[i].getAttribute('y1'))-height);\n\t\t\t}\n\t\t},\n\n\n\t\tfindxs: function() {\n\t\t\tvar v1 = this.serie.searchClosestValue( this.getFromData( 'pos' ).x ),\n\t\t\t\tv2 = this.serie.searchClosestValue( this.getFromData( 'pos2' ).x ),\n\t\t\t\tv3,\n\t\t\t\tinit,\n\t\t\t\tmax,\n\t\t\t\tx=[],\n\t\t\t\ty=[];\n\t\t\t\t\n\t\t\tif(! v1 || ! v2) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t    \n\t\t\tfor(var i = v1.dataIndex; i <= v2.dataIndex ; i++) {\n\n\t\t\t\tinit = i == v1.dataIndex ? v1.xBeforeIndexArr : 0;\n\t\t\t\tmax = i == v2.dataIndex ? v2.xBeforeIndexArr : this.serie.data[i].length;\n\t\t\t\tk = 0;\n\t\t\t\t\n\t\t\t\tfor(j = init; j <= max; j+=2) {\n\t\t\t\t\tx.push(this.serie.data[ i ][ j + 0 ]);\n\t\t\t\t\ty.push(this.serie.data[ i ][ j + 1 ]);\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t\n\t\t\t\n\t\t\tfor(var i=y.length-1;i>=0;i--)\n  \t\t\t\tif(Math.abs(y[i])<this.noiseLevel)\n    \t\t\t\ty[i]=0;\n\t\t\t\n\t\t\tvar dx = x[1]-x[0];\n\t\t\t// fill convolution frecuency axis\n\t\t\tvar X = []//x[2:(x.length-2)];\n\t\n\t\t\t// fill Savitzky-Golay polynomes\n\t\t\tvar Y = [];\n\t\t\tvar dY = [];\n\t\t\tvar ddY = [];\n\t\t\tfor (var j = 2; j < x.length -2; j++){\n\t\t\t\tY.push((1/35.0)*(-3*y[j-2] + 12*y[j-1] + 17*y[j] + 12*y[j+1] - 3*y[j+2]));\n\t\t\t\tX.push(x[j]);\n\t\t\t\tdY.push((1/(12*dx))*(y[j-2] - 8*y[j-1] + 8*y[j+1] - y[j+2]));\n\t\t\t\tddY.push((1/(7*Math.abs(dx*2)))*(2*y[j-2] - y[j-1] - 2*y[j] - y[j+1] + 2*y[j+2]));\n\t\t\t}\n\t\t\n\t\t\t// pushs max and min points in convolution functions\n\t\t\tvar maxY = [];\n\t\t\tvar stackInt = [];\n\t\t\tvar intervals = [];\n\t\t\tvar minddY = [];\n\t\t\tfor (var i = 1; i < Y.length -1 ; i++)\n\t\t\t{\n\t\t\t\tif ((Y[i] > Y[i-1]) && (Y[i] > Y[i+1]))\n\t\t\t\t{\n\t\t\t\t\tmaxY.push(X[i]);\n\t\t\t\t}\n\t\t\t\tif ((dY[i] < dY[i-1]) && (dY[i] < dY[i+1]))\n\t\t\t\t{\n\t\t\t\t\tstackInt.push(X[i]);\n\t\t\t\t}\n\t\t\t\tif ((dY[i] > dY[i-1]) && (dY[i] > dY[i+1]))\n\t\t\t\t{\n\t\t\t\t\ttry{\n\t\t\t\t\t\tintervals.push( [X[i] , stackInt.pop()] );\n\t\t\t\t\t}\n\t\t\t\t\tcatch(e){\n\t\t\t\t\t\tconsole.log(\"Error I don't know why\");\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif ((ddY[i] < ddY[i-1]) && (ddY[i] < ddY[i+1]))\n\t\t\t\t{\n\t\t\t\t\tminddY.push( [X[i], Y[i]] );\n\t\t\t\t}\n\t\t\t}\n\t\t    //console.log(intervals.length);\n\t\t\t// creates a list with (frecuency, linewith, height)\n\t\t\tvar signals = new Array();\n\t\t\tfor (var j = 0; j < minddY.length; j++)\n\t\t\t{\n\t\t\t\tvar f = minddY[j];\n\t\t\t\tvar frecuency = f[0];\n\t\t\t\tvar possible = new Array();\n\t\t\t\tfor (var k=0;k<intervals.length;k++){\n\t\t\t\t    var i = intervals[k];\n\t\t\t\t\tif (frecuency > i[0] && frecuency < i[1])\n\t\t\t\t\t\tpossible.push(i);\n\t\t\t\t}\n\t\t\t\t//console.log(\"possible \"+possible.length);\n\t\t\t\tif (possible.length > 0)\n\t\t\t\t\tif (possible.length == 1)\n\t\t\t\t\t{\n\t\t\t\t\t\tvar inter = possible[0];\n\t\t\t\t\t\tvar linewith = inter[1] - inter[0];\n\t\t\t\t\t\tvar height = f[1];\n\t\t\t\t\t\tvar points = Y;\n\t\t\t\t\t\t//console.log(frecuency);\n\t\t\t\t\t\tpoints.sort(function(a, b){return a-b});\n\t\t\t\t\t\tif ((linewith > 2*dx) && (height > 0.0001*points[0]))\n\t\t\t\t\t\t\tsignals.push( [frecuency, linewith, height] );\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\t//TODO: nested peaks\n\t\t\t\t\t//\tconsole.log(possible);\n\t\t\t\t\t}\n\t\t\t}\n\t\t\t//console.log(signals);\n\t\t\treturn signals;\n\t\t}\n\t});\n\n\treturn GraphNmrSignal1D;\n});\n\n",
    "define( 'assignment',[ 'jquery' ], function( $ ) {\n\n\t\"use strict\";\n\n\tvar ns = 'http://www.w3.org/2000/svg';\n\n\t\tvar Assignment = function( options ) {\n\n\t\t//\tdomMolecule, domGraphs, domGlobal, moleculeFilter, graphs\n\t\t\tvar self = this;\n\n\t\t\tthis.options = options;\n\t\t\tthis.bindingPairs = [];\n\n\t\t\tthis.stashedLines = [];\n\t\t\tthis.currentLines = [];\n\n\n\t\t\tvar binding = false,\n\t\t\tbindingA = false,\n\t\t\tbindingB = false,\n\t\t\tbindingLine,\n\t\t\thighlighted = {},\n\t\t\ttargetting,\n\t\t\t\n\t\t\tmousedown = function( el, event, element ) {\n\n\t\t\t\tcheckBindingPairs();\n\n\t\t\t\tif( event.shiftKey ) {\n\n\t\t\t\t\tfor( var i in options.graphs ) { // We need to lock all graphs to prevent actions on the shapes.\n\t\t\t\t\t\toptions.graphs[ i ].lockShapes();\t\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tbinding = true;\n\t\t\t\t\tself[ element ] = el;\n\n\t\t\t\t\tevent.preventDefault();\n\t\t\t\t\tevent.stopPropagation();\n\t\t\t\t}\n\n\t\t\t\t// Try to be smart and determine where to put the line ?\n\n\t\t\t\tvar bb = el.getBBox();\n\t\t\t\tvar pos = $( el ).position(),\n\n\t\t\t\tx = pos.left + bb.width / 2,\n\t\t\t\ty = pos.top + bb.height / 2;\n\n\t\t\t\tbindingLine.setAttribute('display', 'block');\n\n\t\t\t\tbindingLine.setAttribute('x1', x );\n\t\t\t\tbindingLine.setAttribute('x2', x );\n\n\t\t\t\tbindingLine.setAttribute('y1', y );\n\t\t\t\tbindingLine.setAttribute('y2', y );\n\n\n\n\t\t\t\ttargetting = otherTarget( element ); \n\t\t\t\tif( options[ otherTarget( element ) ].targettable ) {\n\n\t\t\t\t\tvar targetEls = findTargettableElements( otherTarget( element ) );\n\n\t\t\t\t\ttargetEls.each( function( ) {\n\n\t\t\t\t\t\tif( this.jsGraphIsShape ) {\n\n\t\t\t\t\t\t\tthis.jsGraphIsShape.highlight( options[ otherTarget( element ) ].targettable, \"binding\" );\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tstoreAttributes( options[ otherTarget( element ) ].targettable, $( this ) );\n\t\t\t\t\t\t\t$( this ).attr( options[ otherTarget( element ) ].targettable );\n\n\t\t\t\t\t\t}\n\t\t\t\t\t} );\n\t\t\t\t}\n\n\t\t\t},\n\n\t\t\totherTarget = function( target ) {\n\n\t\t\t\tif( target == \"jsGraphShape\") {\n\t\t\t\t\treturn \"targetB\";\n\t\t\t\t}\n\n\t\t\t\treturn \"jsGraphShape\";\n\t\t\t},\n\n\t\t\tfindTargettableElements = function( target ) {\n\n\t\t\t\treturn $( options[ target ].dom ).find( options[ target ].bindableFilter );\n\t\t\t},\n\n\n\t\t\tmouseup = function( el, event, target ) {\n\n\t\t\t\tcheckBindingPairs();\n\t\t\t\t\n\n\t\t\t\tif( targetting ) {\n\n\t\t\t\t\tif( options[ targetting ].targettable ) {\n\n\t\t\t\t\t\tvar targetEls = findTargettableElements( targetting );\n\n\t\t\t\t\t\ttargetEls.each( function( ) {\n\n\t\t\t\t\t\t\tif( this.jsGraphIsShape ) {\n\n\t\t\t\t\t\t\t\tthis.jsGraphIsShape.unHighlight( \"binding\" );\n\n\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\trestoreAttributes( options[ targetting ].targettable, $( this ) );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} );\n\t\t\t\t\t}\n\t\t\t\t\n\n\t\t\t\t}\n\n\t\t\t\ttargetting = false;\n\t\t\t\t\n\t\t\t\tif( binding && ! target ) {\n\t\t\t\t\tbindingLine.setAttribute('display', 'none');\n\t\t\t\t\tbinding = false;\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tif( ! binding ) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tvar domTarget = event.target;\n\t\t\t\tbindingLine.setAttribute('display', 'none');\n\n\t\t\t\tif( ! $( domTarget ).is( options[ target ].bindableFilter ) && ! $( domTarget ).get( 0 ).classList.contains( options[ target ].bindableFilterClass ) > -1 ) {\n\n\t\t\t\t\tbinding = false;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tself[ target ] = event.target;\n\t\t\t\t\tbinding = false;\n\t\t\t\t\tbindSave();\n\t\t\t\t}\n\n\t\t\t\tfor( var i in options.graphs ) { // We can now unlock everything\n\t\t\t\t\toptions.graphs[ i ].unlockShapes();\t\n\t\t\t\t}\t\t\t\n\t\t\t},\n\n\t\t\tmousemove = function( e ) {\n\n\t\t\t\tcheckBindingPairs();\n\t\t\t\t\n\n\t\t\t\tif( ! binding ) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tbindingLine.setAttribute('x2', e.clientX + window.scrollX );\n\t\t\t\tbindingLine.setAttribute('y2', e.clientY + window.scrollY );\n\t\t\t},\n\n\t\t\thighlight = function( element, target ) {\n\t\t\t\t\n\t\t\t\tcheckBindingPairs();\n\t\t\t\t\n\t\t\t\tvar elements = [ element ];\n\t\t\t\tif( options[ target ].highlighted ) {\n\t\t\t\t\telements = getEquivalents( target, element );\n\t\t\t\t\thighlightEquivalents( target, elements );\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t//getEquivalents( target, selector );\n\n\n\t\t\t\tvar eqs = [];\n\t\t\t\t\n//\t\t\t\tunhighlight( element, target );\n\t\t\t\tfor( var i = 0, l = elements.length; i < l; i ++ ) {\n\t\t\t\n\t\t\t\t\tallPairs( highlightPair, elements[ i ], function( pair ) {\n\t\t\t\t\t\teqs = eqs.concat( $.makeArray( getEquivalents( otherTarget( target ), pair[ otherTarget( target ) ] ) ) );\n\t\t\t\t\t} );\n\t\t\t\t}\n\n\t\t\t\t\n\t\t\t\teqs = $( eqs );\n\t\t\t\t\n\t\t\t\tif( options[ otherTarget( target ) ].highlighted ) {\n\t\t\t\t\thighlightEquivalents( otherTarget( target ), eqs );\n\t\t\t\t}\n\t\t\t\t\n\t\t\t},\n\n\t\t\tunhighlight = function( element, target, force ) {\n\n\t\t\t/*\tif( binding && ! force) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n*/\n\t\t\t\tcheckBindingPairs();\n\t\t\t\tvar elements = getEquivalents( target, element );\n\t\t\t\t\n\t\t\t\tvar eqs = [];\n\n\t\t\t\tfor( var i = 0; i < elements.length; i ++ ) {\n\n\t\t\t\t\tallPairs( self.unhighlightPair, elements[ i ], function( pair ) {\n\t\t\t\t\t\teqs = eqs.concat( $.makeArray( getEquivalents( otherTarget( target ), pair[ otherTarget( target ) ] ) ) );\n\t\t\t\t\t} );\n\t\t\t\t}\n\n\n\t\t\t\thighlighted.jsGraphShape.map( function( el ) {\n\t\t\t\t\tthis.jsGraphIsShape.unHighlight( \"assignmentHighlighted\");\n\t\t\t\t} );\n\n\t\t\t\trestoreAttributes( options.targetB.highlighted, highlighted.targetB );\n\t\t\t\t\n\t\t\t},\n\n\t\t\thighlightEquivalents = function( target, elementsToHighlight ) {\n\n\t\t\t\tvar highlightedAttributes = options[ target ].highlighted;\n\n\t\t\t\tif( elementsToHighlight[ 0 ] && elementsToHighlight[ 0 ].jsGraphIsShape ) {\n\n\t\t\t\t\telementsToHighlight.map( function( el ) {\n\n\t\t\t\t\t\tthis.jsGraphIsShape.highlight( highlightedAttributes, \"assignmentHighlighted\");\n\t\t\t\t\t} );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tstoreAttributes( highlightedAttributes, elementsToHighlight );\n\t\t\t\t\telementsToHighlight.attr( highlightedAttributes );\n\n\t\t\t\t}\n\n\t\t\t\thighlighted[ target ] = elementsToHighlight;\n\n\t\t\t},\n\n\t\t\tgetEquivalents = function( target, element ) {\n\t\t\t\tvar selector = element.getAttribute( options[ target ].attributeEquivalents );\n\t\t\t\n\t\t\t\treturn $( options[ target ].dom ).find( \"[\" + options[ target ].attributeEquivalents + \"=\\\"\" + selector + \"\\\"]\");\n\t\t\t},\n\n\t\t\tstoreAttributes = function( attr, els ) {\n\n\t\t\t\tfor( var i in attr ) {\n\t\t\t\t\t\n\t\t\t\t\tfor( var j = 0, l = els.length; j < l; j ++ )  {\n\t\t\t\t\t\t\t\n\t\t\t\t\t\tif( ! $( els[ j ]  ).data( \"backup-\" + i ) ) {\t\n\t\t\t\t\t\t\t$( els[ j ]  ).data( \"backup-\" + i, $( els[ j ]  ).attr( i ) );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t},\n\n\t\t\trestoreAttributes = function( attr, els ) {\n\n\t\t\t\tfor( var i in attr ) {\n\n\t\t\t\t\tfor( var j = 0, l = els.length; j < l; j ++ )  {\n\n\t\t\t\t\t\t$( els[ j ] ).attr( i, $( els[ j ]  ).data('backup-' + i ) );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t},\n\n\t\t\tallPairs = function( fct, element, callback ) {\n\n\t\t\t\tfor( var i = 0, l = self.bindingPairs.length ; i < l ; i ++ ) {\n\n\t\t\t\t\tif( self.bindingPairs[ i ].jsGraphShape == element || self.bindingPairs[ i ].targetB == element ) {\n\n\t\t\t\t\t\tfct.call( self, self.bindingPairs[ i ] );\n\n\t\t\t\t\t\tif( callback ) {\n\t\t\t\t\t\t\tcallback.call( self, self.bindingPairs[ i ] );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t},\n\n\t\t\thighlightPair = function( pair ) {\n\n\n\t\t\t\tvar posA = $( pair.jsGraphShape ).offset();\n\t\t\t\tvar posB = $( pair.targetB ).offset();\n\n\t\t\t\tvar bbA = $( pair.jsGraphShape )[ 0 ].getBBox();\n\t\t\t\tvar bbB = $( pair.targetB )[ 0 ].getBBox();\n\n\t\t\t\tvar posMain = options.domGlobal.offset();\n\n\t\t\t\tvar line;\n\n\t\t\t\tif( self.stashedLines.length > 0 ) {\n\t\t\t\t\tline = self.stashedLines.pop();\n\t\t\t\t\tline.setAttribute('display', 'block');\n\t\t\t\t} else {\n\t\t\t\t\tline = document.createElementNS( ns, 'line');\t\n\t\t\t\t}\n\n\t\t\t\t\n\t\t\t\tline.setAttribute('stroke', 'black');\n\t\t\t\tline.setAttribute('x1', posA.left - posMain.left + bbA.width / 2 );\n\t\t\t\tline.setAttribute('y1', posA.top - posMain.top + bbA.height / 2  );\n\t\t\t\tline.setAttribute('x2', posB.left - posMain.left + bbB.width / 2 );\n\t\t\t\tline.setAttribute('y2', posB.top - posMain.top + bbB.height / 2 );\n\n\t\t\t\tpair.line = line;\n\t\t\t\tself.currentLines.push( line );\n\n\t\t\t\ttopSVG.appendChild( line );\n\t\t\t},\n\n\n\t\t\t\n\n\t\t\tbindSave = function() {\n\n\t\t\t\tvar pair;\n\n\t\t\t\tif( pair = lookForPair( self.jsGraphShape, self.targetB ) ) {\n\t\t\t\t\tremovePair( pair );\n\t\t\t\t\tself.unhighlightPair( pair );\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\n\t\t\t\tunhighlight( self.jsGraphShape, \"jsGraphShape\", true );\n\n\t\t\t\tself.bindingPairs.push( { jsGraphShape: self.jsGraphShape, targetB: self.targetB } );\n\n\t\t\t\tself.jsGraphShape.jsGraphIsShape.setStrokeDasharray(\"5,5\");\n\t\t\t\tself.jsGraphShape.jsGraphIsShape.applyStyle();\n\t\t\t\n\t\t\t\tbindingA = null;\n\t\t\t\tbindingB = null;\n\n\t\t\t},\n\n\n\t\t\tlookForPair = function( A, B ) {\n\n\t\t\t\tfor( var i = 0; i < self.bindingPairs.length; i++ ) {\n\n\t\t\t\t\tif( self.bindingPairs[ i ].jsGraphShape == A || self.bindingPairs[ i ].targetB == B ) {\n\t\t\t\t\t\treturn self.bindingPairs[ i ];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn false;\n\t\t\t},\n\n\n\n\n\t\t\tcheckBindingPairs = function() {\n\n\t\t\t\tfor( var i = 0, l = self.bindingPairs.length ; i < l ; i ++ ) {\n\n\t\t\t\t\tif( $( options.jsGraphShape.dom ).get( 0 ).contains( self.bindingPairs[ i ].jsGraphShape ) && $( options.targetB.dom ).get( 0 ).contains( self.bindingPairs[ i ].targetB ) ) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tself.bindingPairs[ i ] = false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t},\n\n\t\t\tsetEvents = function( ) {\n\n\t\t\t\toptions.jsGraphShape.dom.on('mousedown', options.jsGraphShape.bindableFilter, function( e ) {\n\t\t\t\t\t\n\t\t\t\t\tmousedown( this, e, \"jsGraphShape\" );\n\t\t\t\t});\n\n\t\t\t\toptions.jsGraphShape.dom.on('mouseover', options.jsGraphShape.bindableFilter, function( e ) {\n\t\t\t\t\t\n\t\t\t\t\thighlight( this, \"jsGraphShape\" );\n\t\t\t\t});\n\n\t\t\t\toptions.jsGraphShape.dom.on('mouseout', options.jsGraphShape.bindableFilter, function( e ) {\n\t\t\t\t\tunhighlight( this, \"jsGraphShape\" );\n\t\t\t\t});\n\n\t\t\t\toptions.targetB.dom.on('mousedown', options.targetB.bindableFilter, function( e ) {\n\t\t\t\t\tmousedown( this, e, \"targetB\" );\n\t\t\t\t});\n\n\t\t\t\toptions.targetB.dom.on('mouseover', options.targetB.bindableFilter, function( e ) {\n\t\t\t\t\thighlight( this, \"targetB\" );\n\t\t\t\t});\n\n\t\t\t\toptions.targetB.dom.on('mouseout', options.targetB.bindableFilter, function( e ) {\n\t\t\t\t\tunhighlight( this, \"targetB\" );\n\t\t\t\t});\n\n\t\t\t\toptions.jsGraphShape.dom.on('mouseup', function( e ) {\n\t\t\t\t\tmouseup( this, e, \"jsGraphShape\" );\n\t\t\t\t});\n\n\t\t\t\toptions.targetB.dom.on('mouseup', function( e ) {\n\t\t\t\t\tmouseup( this, e, \"targetB\" );\n\t\t\t\t});\n\n\t\t\t\toptions.domGlobal.on('mouseup', function( e ) {\n\t\t\t\t\tmouseup( this, e, false );\n\t\t\t\t})\n\n\t\t\t\toptions.domGlobal.on('mousemove', function( e ) {\n\t\t\t\t\tmousemove( e );\n\t\t\t\t})\n\t\t\t};\n\n\n\t\t\tvar topSVG = document.createElementNS( ns, 'svg' );\n\t\t\ttopSVG.setAttributeNS(\"http://www.w3.org/2000/xmlns/\", \"xmlns:xlink\", \"http://www.w3.org/1999/xlink\");\n\t\t\ttopSVG.setAttribute('xmlns', ns );\n\t\t\n\t\t\ttopSVG.setAttribute('style', 'position: absolute');\n\t\t\ttopSVG.setAttribute('width', options.domGlobal.width( ) )\n\t\t\ttopSVG.setAttribute('height', options.domGlobal.height( ) )\n\t\t\ttopSVG.setAttribute('pointer-events', 'none');\n\n\t\t\tbindingLine = document.createElementNS( ns, 'line');\n\t\t\tbindingLine.setAttribute('stroke', 'black');\n\n\t\t\ttopSVG.appendChild( bindingLine );\n\n\t\t\toptions.domGlobal.prepend( topSVG );\n\t\t\tsetEvents( );\t\n\t};\n\n\n\tAssignment.prototype.removePair = function( pair ) {\n\n\t\tthis.bindingPairs.splice( this.bindingPairs.indexOf( pair ), 1 );\n\t\tthis.unhighlightPair( pair );\n\t};\n\n\tAssignment.prototype.unhighlightPair = function( pair ) {\n\n\t\tpair.line = false;\n\n\t\tthis.currentLines.map( function( line ) {\n\t\t\tline.setAttribute('display', 'none');\n\t\t} );\n\n\t\tthis.stashedLines = this.stashedLines.concat( this.currentLines );\n\t\tthis.currentLines = [];\n\t};\n\n\n\tAssignment.prototype.getAssignment = function() {\n\n\t\tvar self = this;\n\n\t\treturn this.bindingPairs.map( function( pair ) {\n\n\t\t\tif( ! pair ) {\n\t\t\t\treturn undefined;\n\t\t\t}\n\n\t\t\tvar attrA = pair.jsGraphShape.getAttribute( self.options.jsGraphShape.attributeEquivalents );\n\t\t\tvar attrB = pair.targetB.getAttribute( self.options.targetB.attributeEquivalents );\n\n\t\t\treturn [ attrA, attrB ];\n\t\t} );\n\t}\n\n\tAssignment.prototype.removePairsWithShape = function( shape ) {\n\n\t\tvar self = this;\n\t\tvar pairs = this.lookForPairsByShape( shape ).map( function( pair ) {\n\n\t\t\tself.removePair( pair );\n\n\t\t});\n\t}\n\n\tAssignment.prototype.lookForPairsByShape = function( A ) {\n\n\t\tvar pairs = [];\n\t\tfor( var i = 0; i < this.bindingPairs.length; i++ ) {\n\n\t\t\tif( this.bindingPairs[ i ].jsGraphShape == A ) {\n\t\t\t\tpairs.push( this.bindingPairs[ i ] );\n\t\t\t}\n\t\t}\n\n\t\treturn pairs;\n\t};\n\n\tAssignment.prototype.findElement = function( target, selector ) {\n\n\t\treturn $( this.options[ target ].dom ).find( \"[\" + this.options[ target ].attributeEquivalents + \"=\\\"\" + selector + \"\\\"]\");\t\n\t};\n\n\n\tAssignment.prototype.setAssignment = function( pairs ) {\n\n\t\tvar self = this;\n\t\tself.bindingPairs = [];\n\n\t\tpairs.forEach( function( pair ) {\n\n\t\t\tself.bindingPairs.push( { jsGraphShape: self.findElement( 'jsGraphShape', pair[ 0 ] ), targetB: self.findElement( 'targetB', pair[ 1 ] ) } );\n\t\t} );\n\t}\n\n\treturn Assignment;\n\n});\n\n",
    "define('nmr',[ 'jquery', 'jsgraph', './shape.1dnmr', './assignment', 'jcampconverter', 'eventEmitter' ], function( $, Graph, Shape1DNMR, Assignment, JcampConverter, EE ) {\n\n\t// Root here\n\tvar defaults = {\n\t\tmode: '1d',\n\t\tmolecule: false,\n\t\turls: {\n\n\t\t}\n\t};\n\n\tfunction fetchUrls( nmr, urls ) {\n\n\t\tvar fetching = [];\n\t\tfor( var i in urls ) {\n\t\t\tfetching.push( $.get( urls[ i ] ).then( function( data ) { return JcampConverter.convert( data, {keepSpectra:true} ) } ) );\n\t\t}\n\n\t\tif( ! nmr.divLoading ) {\n\n\t\t\tnmr.divLoading = $(\"<div />\").css( {\n\n\t\t\t\twidth: nmr.getDom().width(),\n\t\t\t\theight: nmr.getDom().height(),\n\t\t\t\tposition: 'absolute',\n\t\t\t\tbackgroundColor: 'rgba(200, 200, 200, 0.5)',\n\t\t\t\ttextAlign: 'center',\n\t\t\t\tlineHeight: nmr.getDom().height() + \"px\",\n\t\t\t\tfontSize: '2em',\n\t\t\t\tborder: \"1px solid #c0c0c0\"\n\n\t\t\t} ).html(\"Loading...\");\n\n\t\t\tnmr.getDom().prepend( nmr.divLoading );\n\t\t}\n\n\t\tnmr.loading = nmr.loading || 0\n\t\tnmr.loading++;\n\n\t\t$.when.apply( $, fetching ).then( function() {\n\n\t\t\tvar j = 0;\n\t\t\tfor( i in urls ) {\n\n\t\t\t\turls[ i ] = arguments[ j ];\n\t\t\t\tj++;\n\t\t\t}\n\n\t\t\tnmr.loading--;\n\t\t\tif( nmr.loading == 0 ) {\n\t\t\t\tnmr.divLoading.remove();\n\t\t\t\tnmr.divLoading = false;\n\t\t\t}\n\n\t\t\tnmr.series.push( urls );\n\t\t\tnmr.loaded( urls, \"a\" + Math.random() );\n\t\t} );\n\t}\n\n\tfunction makeNMRIntegral( nmr, mode, integral ) {\n\t\t// External call\n\t\tvar shape = nmr.graphs.newShape( { \n\t\t\t\ttype: 'nmrintegral', \n\t\t\t\tfillColor: 'transparent', \n\t\t\t\tstrokeColor: '#AF002A', \n\t\t\t\tstrokeWidth: '2px',\n\t\t\t\tselectOnClick: true,\n\t\t\t\thandles: true,\n\t\t\t\tlabel: {\n\t\t\t\t\tposition: { },\n\t\t\t\t\ttext: 1,\n\t\t\t\t\tcolor: 'red',\n\t\t\t\t\tanchor: 'middle'\n\t\t\t\t},\n\n\t\t\t\tshapeOptions: {\n\t\t\t\t\tlocked: true\n\t\t\t\t}\n\t\t\t } );\n\t\t\n\t\tshape.setSerie( nmr.getGraphX().getSerie( 0 ) );\n\t\tshape.setLabelText( \"NMRVal\" );\n\t\tshape.draw();\n\t\tshape.redraw();\n\n\n\n\t\treturn shape;\n\t}\n\t\n\tfunction removeSerie( nmr, name ) {\n\n\n\t\tvar serie;\n\t\tif( ( serie = nmr.graphs.getSerie( name ) ) ) {\n\t\t\tserie.kill();\n\t\t}\n\n\t\tnmr.graphs.redraw();\n\t\tnmr.graphs.drawSeries();\n\t}\n\n\t\t\n\tGraph.registerConstructor(\"graph.shape.1dnmr\", Shape1DNMR);\n\n\tfunction NMR( options ) {\n\n\t\tvar nmr = this;\n\n\t\tthis.options = $.extend( true, {}, defaults, options );\n\t\tthis.series = [];\n\t\tthis.integrals = [];\n\n\t\tnmr.options.dom.append('<div />');\n\t\tnmr.makeGraph();\n\n\t\tswitch( this.options.mode ) {\n\t\t\tcase '2d':\n\t\t\t\t\n\t\t\tbreak;\n\n\t\t\tcase '1d':\n\t\t\t\tthis.legend = this.graphs.makeLegend( { frame: true, frameWidth: 2, frameColor: 'grey', movable: true, backgroundColor: 'white' } );\n\t\t\t\tthis.legend.setPosition( { x: \"300px\", y: \"40px\" }, 'right' );\n\n\t\t\tbreak;\n\t\t}\n\n\t\tif( this.options.assignment ) {\n\t\t\tthis.assignement = new Assignment( $.extend( this.options.assignment, { graphs: { 'x': this.graphs }, domGraphs: this.options.dom } ) );\t\n\t\t}\n\n\n\t\tthis.heightIntegral1 = 150;\n\t}\n\n\n\tvar loadDefaults = {\n\t\turls: {}\n\t};\n\n\tNMR.prototype = new EE();\n\n\tNMR.prototype.load = function( load ) {\n\n\t\tvar load = $.extend( true, {}, loadDefaults, load );\n\t\tvar urls = {};\n\t\tswitch( this.options.mode ) {\n\n\n\t\t\tcase '1d':\n\t\t\t\t\n\t\t\t\tload.urls.oneD = load.url || load.urls.oneD || load.urls.x;\n\t\t\t\turls.x = load.urls.oneD;\t\n\n\n\t\t\tbreak;\n\t\t}\n\n\n\t\tfetchUrls( this, urls, load );\n\t};\n\n\tNMR.prototype.loadJcamp = function (jcamp, name) {\n\t    removeSerie(this, name);\n        const data = JcampConverter.convert( jcamp, {keepSpectra:true} );\n        this.loaded( {x: data}, name );\n    };\n\n\tNMR.prototype.integralCreated = function( integral ) {\n\n\t\tif( this.graphs.selectedSerie ) {\n\t\t\tintegral.setSerie( this.graphs.selectedSerie );\n\t\t} else {\n\t\t\tintegral.setSerie( this.graphs.getSerie( 0 ) );\n\t\t}\n\t\t\n\t\tintegral.addClass('bindable');\n\t\tthis.integrals.push( integral );\n\n\t\tthis.emit( \"integralCreated\" );\n\t}\n\n\tNMR.prototype.integralChanged = function( integral ) {\n\t\tthis.recalculateIntegrals( );\n\n\t\tthis.emit( \"integralChanged\" );\n\t}\n\n\tNMR.prototype.integralRemoved = function( integral ) {\n\n\t\tthis.integrals.splice( this.integrals.indexOf( integral ), 1 );\n\t\tthis.recalculateIntegrals( );\n\t\tthis.assignement.removePairsWithShape( integral._dom );\n\t\tthis.emit( \"integralRemoved\" );\n\t}\n\n\n\tNMR.prototype.recalculateIntegrals = function( ) {\n\n\t\tvar nmr = this,\n\t\t\tnumberOfIntegrals = nmr.integrals.length;\n\n\t\tif( numberOfIntegrals == 1 ) {\n\t\t\tnmr.ratio = nmr.heightIntegral1 / nmr.integrals[ 0 ].sum;\n\t\t\tnmr.ratioSum = nmr.integrals[ 0 ].sum;\n\t\t}\n\n\t\t\n\t\tfor( var i = 0; i < numberOfIntegrals ; i ++ ) {\n\n\t\t\tnmr.integrals[ i ].ratio = nmr.ratio;\n\n\t\t\tvar text = Math.round( nmr.integrals[ i ].sum / nmr.ratioSum * 100 ) / 100;\n\t\t\tif( ! isNaN( text ) ) {\n\t\t\t\tnmr.integrals[ i ].setLabelText( text );\n\t\t\t}\n\n\t\t\tnmr.integrals[ i ].updateLabels();\n\t\t}\n\t}\n\n\tNMR.prototype.redrawIntegrals = function() {\n\n\t\tvar l = this.integrals.length;\n\t\tfor( var i = 0; i < l; i++ ) {\n\t\t\tthis.integrals[ i ].redraw();\n\t\t}\n\t}\n\n\tNMR.prototype.integralValueChanged = function( integral ) {\n\n\t\tvar fl = parseFloat( integral.getLabelText( 0 ) );\n\t\tthis.ratioSum = integral.sum / fl;\n\t\tthis.recalculateIntegrals( );\n\t\tthis.emit( \"integralValueChanged\" );\n\t}\n\n\tNMR.prototype.getDom = function() {\n\t\treturn this.options.dom;\n\t};\n\n\tNMR.prototype.getGraph = function() {\n\t\treturn this.graphs;\n\t};\n\n\tNMR.prototype.resizeTo = function( w, h ) {\n\t\tthis.graphs.resize( w, h );\n\t};\n\n\tNMR.prototype.setSerieX = function( name, data, options ) {\n\n\t\tif( this.graphs.getSerie( name ) ) {\n\n\t\t\tthis.graphs.getSerie( name ).kill();\n\t\t\tthis.graphs.removeShapes();\n\t\t\tthis.integralBasis = false;\n\n\t\t}\n\n\t\tvar serie_x = this.graphs.newSerie( name, $.extend( { useSlots: true }, options ) )\n\t\t\t.setLabel( \"My serie\" )\n\t\t\t.autoAxis()\n\t\t\t.setData( data )\n\t\t\t.XIsMonotoneous();\n\n\t\tif( options.lineColor ) {\n\t\t\tserie_x.setLineColor( options.lineColor );\n\t\t}\n\n\t\tif( options.lineWidth ) {\n\t\t\tserie_x.setLineWidth( options.lineWidth );\n\t\t}\n\n\t\tif( options.setLineStyle ) {\n\t\t\tserie_x.setLineStyle( options.lineStyle );\n\t\t}\n\n\t\tserie_x.XIsMonotoneous();\n\t\tserie_x.getXAxis().setAxisDataSpacingMax(0);\n\t\tserie_x.getXAxis().setAxisDataSpacingMin(0);\n\n\t\tserie_x.getYAxis().setDisplay( false ).primaryGridOff( false ).secondaryGridOff( false );\n\t\tserie_x.getXAxis().flip(true).setLabel('ppm').primaryGridOff( false ).secondaryGridOff( false ).setTickPosition( 'outside' )\n\n\t\tthis.graphs.autoscaleAxes();\n\t\tthis.graphs.draw();\n\t};\n\n\n\tNMR.prototype.loaded = function( series, name ) {\n\n\t\n\t\tthis.setSerieX( name, series.x.spectra[ 0 ].data[ 0 ], { label: name } );\n\n\t};\n\n\n\tNMR.prototype.makeGraph = function() {\n\n\t\tvar self = this;\n\n\t\tthis.graphs = new Graph( this.getDom().children().get(0), {\n\n\t\t\tclose: { left: false, top: false, right: false },\n\t\t\tpaddingBottom: 0,\n\t\t\tpaddingTop: 0,\n\t\t\tpaddingLeft: 0,\n\t\t\tpaddingRight: 0,\n\n\t\t\tplugins: {\n\t\t\t\t'zoom': { \n\t\t\t\t\tzoomMode: 'x'\n\n\t\t\t\t},\n\n\t\t\t\t'shape': { \n\t\t\t\t\ttype: 'nmrintegral',\n\t\t\t\t\tstrokeColor: '#AF002A', \n\t\t\t\t\tfillColor: \"transparent\",\n\t\t\t\t\tstrokeWidth: 2,\n\n\t\t\t\t\tlocked: false,\n\t\t\t\t\tmovable: true,\n\t\t\t\t\tresizable: true,\n\t\t\t\t\tselectable: true,\n\t\t\t\t\tselectOnMouseDown: true,\n\t\t\t\t\thandles: true,\n\t\t\t\t\tlabelEditable: true,\n\n\t\t\t\t\thorizontal: true, \n\t\t\t\t\tforcedCoords: { y: function( shape ) { return ( 20 + shape.serie.getIndex() * 5 ) + \"px\"; } },\n\t\t\t\t\tbindable: true,\n\t\t\t\t\taxis: 'x',\n\n\t\t\t\t\tlabels: [ { text: \"Something\", color: 'red' } ] ,\n\n\n\n\t\t\t\t\tattributes: { 'data-bindable': function() { return Math.random(); }, 'id': function() { return Math.random(); } },\n\n\t\t\t\t\tonCreatedShape: function( shape ) {\n\n\t\t\t\t\t\tshape.addAttribute( 'id', Math.random() );\n\t\t\t\t\t\tself.integralCreated( shape );\n\t\t\t\t\t},\n\n\t\t\t\t\tonBeforeNewShape: function( shape, event ) {\n\n\t\t\t\t\t\tif( event.target.classList.contains( 'bindable' ) > 0 ) {\n\t\t\t\t\t\t\tthis.graph.prevent( true );\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t},\n\n\n\t\t\t\t\thighlightOnMouseOver: true\n\t\t\t\t},\n\t\t\t},\n\n\t\t\tmouseActions: [\n\t\t\t\t{ plugin: 'zoom', shift: false, ctrl: false },\n\t\t\t\t{ plugin: 'shape', shift: true, ctrl: false },\n\t\t\t\t{ plugin: 'zoom', shift: false, type: 'mousewheel', options: { baseline: 0, direction: 'y' } },\n\t\t\t\t{ shift: true, type: 'mousewheel', callback: function( delta ) {\n\n\t\t\t\t\tvar change = delta / 300;\n\t\t\t\t\tself.heightIntegral1 += change;\n\t\t\t\t\tself.ratio = self.heightIntegral1 / self.integrals[ 0 ].sum;\n\t\t\t\t\tself.recalculateIntegrals();\n\t\t\t\t\tself.redrawIntegrals();\n\t\t\t\t} },\n\t\t\t\t{ plugin: 'zoom', shift: false, type: 'dblclick', options: { mode: 'total' } }\n\n\t\t\t],\n\n\t\t\tonBeforeNewShape: function() {\n\n\t\t\t\tif( ! this.selectedSerie && this.series.length > 1 ) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\n\t\t} );\n\n\n\t\tthis.graphs.setHeight(300);\n\n\n\t\tthis.graphs.on(\"shapeRemoved\", function( shape ) {\n\n\t\t\tif( shape.getType() == 'nmrintegral' ) {\n\t\t\t\tself.integralRemoved( shape );\n\t\t\t}\n\t\t});\n\n\t\tthis.graphs.on(\"shapeChanged\", function( shape ) {\n\n\t\t\tif( shape.getType() == \"nmrintegral\" ) {\n\n\t\t\t\tself.integralChanged( shape );\n\t\t\t}\n\t\t});\n\n\t\tthis.graphs.on(\"shapeLabelChanged\", function( shape ) {\n\n\t\t\tif( shape.getType() == \"nmrintegral\" ) {\n\n\t\t\t\tself.integralValueChanged( shape );\n\t\t\t}\n\t\t} );\n\n\t\tthis.graphs.draw( );\t\n\t\t\n\t};\n\n\tNMR.prototype.getIntegrals = function() {\n\t\treturn this.integrals.map(shape => shape.getProperties());\n\t};\n\n\tNMR.prototype.setIntegrals = function(integrals) {\n\t\tintegrals.forEach(integral => {\n\t\t\tconst shape = this.graphs.newShape('nmrintegral', null, false, integral);\n\t\t\tthis.integralCreated(shape);\n\t\t});\n\t\tthis.redrawIntegrals();\n\t};\n\n\treturn NMR;\n\t\n\n});\n\n"
  ]
}